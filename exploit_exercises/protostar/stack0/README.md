# Protostar - Stack 0

> NOTE: This writeup is __not__ written by me, John Hammond. This writeup is shamelessly stolen from [Maxime Peterlin](https://rainbowlyte.com/) (because he has done a much better job than I ever could), and the real original writeup can be found here: [https://github.com/RainbowLyte/writeups/blob/master/exploit-exercises_Protostar/stack0.md](https://github.com/RainbowLyte/writeups/blob/master/exploit-exercises_Protostar/stack0.md)

### About ###

>This level introduces the concept that memory can be accessed outside of its allocated region, how the stack variables are laid out, and that modifying outside of the allocated memory can modify program execution.
>
>This level is at `/opt/protostar/bin/stack0`

### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  modified = 0;
  gets(buffer);

  if(modified != 0) {
      printf("you have changed the 'modified' variable\n");
  } else {
      printf("Try again?\n");
  }
}
```

### Solution ###

This first challenge is an introduction to stack buffer overflows. The goal is to change the value of the variable `modified`.
The executable `stack0` is a 32-bit LSB ELF with no software protection, which can be verified with [checksec.sh](http://www.trapkit.de/tools/checksec.html)


```
user@protostar:/tmp$ ./checksec.sh --file /opt/protostar/bin/stack0
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
No RELRO        No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   /opt/protostar/bin/stack0
```

The local variables of the function `main` (`modified` and `buffer`) are located on the stack of the process. We can write in the array `buffer` with the function `gets`. 

Initially the stack frame is as follows:

`main` Stack Frame variables | `main` Stack Frame values
---:|:---
buffer[0:3] | `0x00000000`
buffer[4:7] | `0x00000000`
... | `0x00000000`
buffer[60:63] | `0x00000000`
modified | `0x00000000`
Saved ebp | `0xbffff818`

Now, if the input is "hello" (`0x68656c6c6f` with the ASCII values), the stack frame will look like this:

`main` Stack Frame variables | `main` Stack Frame values
---:|:---
buffer[0:3] | `0x6c6c6568`
buffer[4:7] | `0x0000006f`
... | `0x00000000`
buffer[60:63] | `0x00000000`
modified | `0x00000000`
Saved ebp | `0xbffff818`

> The bytes are "inverted" because the executable is [LSB](https://en.wikipedia.org/wiki/Endianness)

In these scenarios, everything works as intended. Although, since `gets` does not check the size of our input, we can provide a string with a length greater than 64 characters and that's how we can change the value of `modified`.
So, if our input is 65 times `A` (ASCII code `0x41`), `modified` will have the value `0x41`.

`main` Stack Frame variables | `main` Stack Frame values
---:|:---
buffer[0:3] | `0x41414141`
buffer[4:7] | `0x41414141`
... | `0x41414141`
buffer[60:63] | `0x41414141`
modified | `0x00000041`
Saved ebp | `0xbffff818`

```
user@protostar:/tmp$ python -c "print 'A'*64" | /opt/protostar/bin/stack0
Try again?
user@protostar:/tmp$ python -c "print 'A'*65" | /opt/protostar/bin/stack0
you have changed the 'modified' variable
```

